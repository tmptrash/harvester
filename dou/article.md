# Як я створив бібліотеку для витягування даних с DOM

Це маленька історія про написання невеличкої npm бібліотеки для парсінгу і пошуку даних в динамічному DOM дереві. Створено на основі нещодавнього офлайн виступу на [fwdays](https://fwdays.com/en/event/react-fwdays-2025) конференції. Це смішно, але на самій презентації я висловив припущення, що це моя остання презентація коду, який я писав руками :)

## Вступ

Сучасний веб — хаотичний. І хоча HTML виглядає як дерево, у реальних умовах він нагадує **зарості тропічного лісу**: глибокий, непослідовний і непередбачуваний. Кожен розробник пише код по різному, в свому стилі і по своїх правилах. Тому, веб скрапінг іноді потребує додаткових зусиль, якщо ми хочемо отримати бажані дані. І щоб мінімізувати ці зусилля, була створена проста npm бібліотека, яка трішки спрощую цей процес.

Коли мені було потрібно витягати щось з різних сайтів, я робив це "руками". Наприклад, якщо треба зібрати інформацію про товари на розетці нам були б потрібні такі поля:
* назва товару
* ціна
* фото
* SKU
* щось додаткове

Думаю ви не раз бачили як виглядає цей сайт. Ось приклад однієї із сторінок з рандомними товарами:

![image](https://github.com/tmptrash/harvester/blob/main/dou/slides/Screenshot%202025-11-30%20at%2014.47.09-cut.png?raw=true)

Наприклад, якщо нам потрібно витягнути, якійсь товар, все виглядає красиво, доки не заглянеш у DOM і не починаєш створювати query до елементів...

## Проблема: динамічний DOM постійно ламає ваші селектори

Давайте спробуємо абстрагуватись і вирішити проблему більш глобально. Ось типова HTML-картка товару в інтернет-магазині (зліва і справа один й той самий товар за різних умов):

![image](https://github.com/tmptrash/harvester/blob/main/dou/slides/Screenshot%202025-11-30%20at%2014.48.07-cut.png?raw=true)

Структури різні. Теги різні. Порядок різний. Але товар той самий. Чому так? Тому що, сучасні сайти використовують різні фреймворки, які генерують HTML динамічно в залежності від цих самих умов. Наприклад, для адміністратора або звичайного користувача, сторінка може виглядати по разному. І це нормально...

Для прикладу вище, ваш код, для пошуку потрібних елементів імовірно, виглядає ось так:

![image](https://github.com/tmptrash/harvester/blob/main/dou/slides/Screenshot%202025-11-30%20at%2014.48.44-cut.png?raw=true)

І все це перестає працювати, якщо:
* програміст замінив `<h1>` на `<div>`
* з’явився новий `<span>`
* переставили елементи місцями
* додались нові елементи
* змінити або забрали `id`
* і т.п.

Проблема тут фундаментальна: для пошуку даних **ми описуємо структуру DOM, а не самі дані.**

## Ідея: описувати дані, а не структуру DOM

Я сформулював головне питання: **“як дістати дані, мінімально опираючись на структуру DOM?”**. Це привело мене до ідеї розробити **DSL** — маленької мови, яка описує саме дані, а не структуру DOM. Так з’явився проєкт **Harvester**.

## Що таке Harvester?

**Harvester** — це бібліотека для опису даних у вигляді простого текстового tree-like шаблону, який:
* легко писати
* легко читати
* слабо залежить від конкретного DOM
* толерантний до зміни верстки
* знаходить дані навіть якщо нема за що зачепитись (нема id, класів і т.п.)

Давайте глянемо на код для пошуку даних з прикладу, який ми розглядали вище:

![image](https://github.com/tmptrash/harvester/blob/main/dou/slides/Screenshot%202025-11-30%20at%2014.48.55-cut.png?raw=true)

Справа-зверху ви можете бачити приклад шаблону, який описує продукт, його ціну, картинку та SKU (унікальний номер) для обох випадків. Давайте трішки зупинимось на його форматі. Загалом - це проста багаторядкова JS стрічка, яка описує дерево даних. Кожна лінія - це тег в DOM дереві, де ми вказуємо деталі пошуку тексту в цьому тезі. Структура не обов'язково має бути схожа на фактичний DOM. Вона має бути як мінімум близька до оригінальної. Кожна стрічка має містити ім'я тегу, опціональну змінну для тексту і опціональну змінну для атрибуту. Ось список прикладів строк для формування шаблонів пошуку даних:

* `*` — означає "шукати будь-який тег"
* `div` - означає "шукати конкретне ім'я тегу" (може бути `span`, `head`, що завгодно)
* `span{price:float}` - означає "шукати `span` з числом типу `float` всередині" і покласти число в змінну `price`
* `img[img=src]` - означає "шукати тег `img` з атрибутом `src`" і покласти значення в змінну `img`
* `div{sku:with:SKU}` - означає "шукати тег `div` с текстом, який має підтекст 'SKU'" і покласти в змінну `sku`
* `p{text}[attr=ref]` - означає "шукати тег `p` с будь яким текстом і атрибутом `ref`" і покласти текст в змінну `text`, а атрибут в змінну `attr`

Справа - знизу на малюнку Ви можете побачити приклад того, що повертає бібліотека. Це звичайний JSON, ключі якого - це наші змінні, яки ми зазначили в шаблоні (product, price, img, sku).

## Як працює Harvester всередині

![image](https://github.com/tmptrash/harvester/blob/main/dou/slides/Screenshot%202025-11-30%20at%2014.50.49-cut.png?raw=true)

На малюнку показано як саме бібліотека порівнює два дерева - дерево наших даних, яке ми отримали із DSL шаблона (на малюнку зліва - з гілками klm) і DOM дерево (на малюнку правіше з гілками 1234...). Справа і знизу Ви можете побачити частину варіантів, які бібліотека порівнює по факту. Спочатку вона намагається знайти всі гілки (всі три klm) з DSL шаблону і якщо це неможливо, то продовжує з меньшим деревом (kl, km, lm) і так до найменьшого дерева (тільки одна гілка k або l або m).

Бібліотека використовує **fuzzy tree matching**:

1. Розбирає DSL шаблон у JSON дерево
2. Проходить по DOM
3. Шукає найближчу відповідність
4. Вичитує текст/числа/атрибути згідно з типами
5. Повертає результат у вигляді JSON

### Трішки деталей

Давайте розглянемо детальніше як саме harvester розуміє які саме дані підходять під наш шаблон. На малюнку нижче Ви можете бачити розрахунки так званого `score`. Score - це звичайне ціле значення, яке розраховується для кожної гілкі окремо. Все дерево (зі всіма внутрішніми гілками) теж буде мати свій score і так до root гілки. не стільки важливо як саме воно розраховується, як те, що саме значення говорить нам про те, на скільки та чи інша гілка схожа на ту, що ми шукаємо.

![image](https://github.com/tmptrash/harvester/blob/main/dou/slides/Screenshot%202025-11-30%20at%2014.51.06-cut.png?raw=true)

Загальний алгоритм такий: спочатку ми розраховуємо максимально можливий score для кожної гілки і зберігаємо його десь всередині бібліотеки. Далі, під час пошуку ми рахуємо score для кожної DOM гілки в якій ми шукаємо наші дані і обираємо ту, в якій він максимальний. Так ми можемо бути впевненими, що обрані нами дані будут максимально відповідати тим, яки ми описали в шаблоні. Не забувайте, що все, що ми знайшли не буде на 100% тим, що ми по факту шукали. Тому що шаблон міг бути неточним або таких даних просто нема або вони є і дуже схожі на ті, що нам потрібні. Тому це все скоріше верогідністний процес.

## Що це все нам дає?

Маючи таку бібліотеку ми можемо піти далі використовуючи її разом із такими гигантами як [Puppeteer](https://pptr.dev) та [Playwright](https://playwright.dev/) для більш специфічного скрапінгу. На сторінці harvester на github в папці `examples` можна знайти пару прикладів використання harvester із Puppeteer та Playwright. Давайте глянемо на один з такиз прикладів:

![image](https://github.com/tmptrash/harvester/blob/main/dou/slides/Screenshot%202025-12-25%20at%2015.49.10-cut.png?raw=true)

В данному випадку ми витягуємо всі новини за сьогодні з сайту [pravda.com.ua](https://www.pravda.com.ua) за дуже простим шаблоном (дивись константу TPL) в якому ми беремо час та назву новини. Це відбувається за допомогою хелпер функціх `harvestPageAll()`, тоб-то "витягнути все по заданому query" (дивись `NEWS_QUERY`) зі сторінки `page`. Ось і все. Приклади для Playwright майже нічим не відрізняються і знаходяться так само в папці `examples`.

## Проблеми, які довелося вирішити:

* адські рекурсії і глибокий DOM
* схожі теги
* невідповідність рівнів даних в DOM і в шаблоні
* часткові збіги
* експоненційне зростання комбінацій
* дике гальмування при глибокому парсінгу DOM


## Pros and cons

* Декларативність
* Немає прив'язки до структури DOM, id або класів
* Невеликий розмір (приблизно 790 рядків коду)
* Толерантна до змін в DOM
* Швидка
* Витягає всі поля за один виклик функции `harvest()`
* Підтримує різні типи даних
* Сумісний із Puppeteer/Playwright
* Не має залежностей від інших бібліотек

## Репозиторій

**[https://github.com/tmptrash/harvester](https://github.com/tmptrash/harvester)**
